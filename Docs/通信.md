# WebView2 通信方式详解

本文档详细介绍 WebView2 中 C# 与 JavaScript 之间的各种通信方式，包括 postMessage、HostObjects、ExecuteScriptAsync、消息管道等。

---

## 目录

1. [通信方式概览](#1-通信方式概览)
2. [方式一：postMessage（当前使用）](#2-方式一postmessage当前使用)
3. [方式二：HostObjects（对象注入）](#3-方式二hostobjects对象注入)
4. [方式三：ExecuteScriptAsync（脚本执行）](#4-方式三executescriptasync脚本执行)
5. [方式四：消息管道（CoreWebView2WebMessagePipe）](#5-方式四消息管道corewebview2webmessagepipe)
6. [方式对比与选择](#6-方式对比与选择)
7. [混合使用场景](#7-混合使用场景)

---

## 1. 通信方式概览

WebView2 提供了多种 C# 与 JavaScript 通信的方式：

| 方式 | 方向 | 特点 | 适用场景 |
|------|------|------|----------|
| **postMessage** | JS → C# | 异步消息传递 | 事件通知、命令调用 |
| **HostObjects** | C# ↔ JS | 对象代理 | 直接调用 C# 方法 |
| **ExecuteScriptAsync** | C# → JS | 执行 JS 代码 | 主动调用 JS 函数 |
| **消息管道** | C# ↔ JS | 双向流式通信 | 实时数据流 |

---

## 2. 方式一：postMessage（当前使用）

### 2.1 原理

**JavaScript → C#** 的单向消息传递机制。

```
┌─────────────┐                    ┌─────────────┐
│  JavaScript │  postMessage()     │     C#      │
│             │ ──────────────────>│             │
│             │                    │ WebMessage  │
│             │                    │  Received   │
└─────────────┘                    └─────────────┘
```

### 2.2 实现代码

#### JavaScript 端

```javascript
// 发送消息
window.chrome.webview.postMessage({
    messageType: 'setState',
    payload: { width: 1500 }
});
```

#### C# 端

```csharp
// 注册事件
WebView.CoreWebView2.WebMessageReceived += OnWebMessageReceived;

// 接收消息
private void OnWebMessageReceived(object? sender, CoreWebView2WebMessageReceivedEventArgs e)
{
    var message = e.WebMessageAsJson;
    var json = JsonDocument.Parse(message);

    var messageType = json.RootElement.GetProperty("messageType").GetString();
    var payload = json.RootElement.GetProperty("payload");

    // 处理消息
    HandleMessage(messageType, payload);
}
```

### 2.3 优点

- ✅ **简单可靠**：API 简单，不易出错
- ✅ **类型安全**：通过 JSON 序列化，类型明确
- ✅ **解耦**：JavaScript 不需要知道 C# 的实现细节
- ✅ **易于调试**：消息格式清晰，便于日志记录

### 2.4 缺点

- ❌ **单向通信**：只能 JS → C#，C# 无法直接回复
- ❌ **需要序列化**：大数据量时性能较差
- ❌ **无返回值**：JavaScript 无法获取调用结果

### 2.5 适用场景

- 事件通知（按钮点击、表单提交）
- 命令调用（创建洞口、保存设置）
- 状态更新（修改 ViewModel 属性）

---

## 3. 方式二：HostObjects（对象注入）

### 3.1 原理

将 C# 对象注入到 JavaScript 环境，JavaScript 可以**直接调用** C# 方法。

```
┌─────────────┐                    ┌─────────────┐
│  JavaScript │                    │     C#      │
│             │  直接调用方法       │             │
│ hostObject  │ ──────────────────>│  C# Object  │
│  .method()  │ <──────────────────│             │
│             │  返回结果           │             │
└─────────────┘                    └─────────────┘
```

### 3.2 实现代码

#### C# 端：创建可注入的类

```csharp
using System.Runtime.InteropServices;

[ClassInterface(ClassInterfaceType.AutoDual)]
[ComVisible(true)]
public class RevitBridge
{
    private readonly WallOpeningViewModel _viewModel;

    public RevitBridge(WallOpeningViewModel viewModel)
    {
        _viewModel = viewModel;
    }

    // JavaScript 可以直接调用这个方法
    public void SetWidth(double width)
    {
        _viewModel.Width = width;
    }

    // 返回值会自动传递给 JavaScript
    public double GetWidth()
    {
        return _viewModel.Width;
    }

    // 支持异步方法
    public async Task<string> CreateOpeningAsync()
    {
        // 执行业务逻辑
        await Task.Delay(1000);
        return "洞口创建成功";
    }
}
```

#### C# 端：注入对象

```csharp
private async Task InitializeWebViewAsync()
{
    await WebView.EnsureCoreWebView2Async();

    // 创建桥接对象
    var bridge = new RevitBridge(_viewModel);

    // 注入到 JavaScript 环境
    WebView.CoreWebView2.AddHostObjectToScript("revitBridge", bridge);

    // 加载页面
    WebView.CoreWebView2.Navigate("https://revitflow.local/index.html");
}
```

#### JavaScript 端：调用 C# 方法

```javascript
// 直接调用 C# 方法
window.chrome.webview.hostObjects.revitBridge.SetWidth(1500);

// 获取返回值
const width = window.chrome.webview.hostObjects.revitBridge.GetWidth();
console.log('当前宽度:', width);

// 调用异步方法
window.chrome.webview.hostObjects.revitBridge.CreateOpeningAsync().then(result => {
    console.log(result); // "洞口创建成功"
});
```

### 3.3 优点

- ✅ **双向通信**：JavaScript 可以调用 C# 方法并获取返回值
- ✅ **类型安全**：C# 方法签名明确，IDE 有智能提示
- ✅ **支持异步**：可以使用 `async/await`
- ✅ **无需序列化**：简单类型自动转换

### 3.4 缺点

- ❌ **需要 COM 可见**：类必须标记 `[ComVisible(true)]`
- ❌ **性能开销**：每次调用都有 COM 互操作开销
- ❌ **类型限制**：只支持简单类型（int, string, double 等）
- ❌ **调试困难**：错误信息不清晰
- ❌ **紧耦合**：JavaScript 依赖 C# 的具体实现

### 3.5 适用场景

- 需要获取返回值的场景
- 频繁调用 C# 方法
- 简单的数据查询（获取配置、状态等）

### 3.6 完整示例

```csharp
// C# 端
[ClassInterface(ClassInterfaceType.AutoDual)]
[ComVisible(true)]
public class RevitBridge
{
    public string GetVersion() => "1.0.0";

    public bool ValidateInput(string input)
    {
        return !string.IsNullOrEmpty(input);
    }

    public async Task<string> SaveSettingsAsync(string json)
    {
        await Task.Delay(500);
        return "保存成功";
    }
}

// 注入
WebView.CoreWebView2.AddHostObjectToScript("bridge", new RevitBridge());
```

```javascript
// JavaScript 端
const bridge = window.chrome.webview.hostObjects.bridge;

// 同步调用
const version = bridge.GetVersion();
console.log('版本:', version); // "1.0.0"

// 验证输入
const isValid = bridge.ValidateInput("test");
console.log('有效:', isValid); // true

// 异步调用
bridge.SaveSettingsAsync('{"theme":"dark"}').then(result => {
    console.log(result); // "保存成功"
});
```

---

## 4. 方式三：ExecuteScriptAsync（脚本执行）

### 4.1 原理

C# 主动执行 JavaScript 代码，可以调用 JavaScript 函数并获取返回值。

```
┌─────────────┐                    ┌─────────────┐
│  JavaScript │                    │     C#      │
│             │ <──────────────────│             │
│  function() │  ExecuteScript     │             │
│             │ ──────────────────>│             │
│             │  返回结果           │             │
└─────────────┘                    └─────────────┘
```

### 4.2 实现代码

#### C# 端：执行 JavaScript

```csharp
// 执行简单的 JavaScript 代码
await WebView.CoreWebView2.ExecuteScriptAsync("alert('Hello from C#')");

// 调用 JavaScript 函数
await WebView.CoreWebView2.ExecuteScriptAsync("updateUI('loading')");

// 获取返回值
string result = await WebView.CoreWebView2.ExecuteScriptAsync("getUsername()");
Console.WriteLine($"用户名: {result}");

// 传递参数（需要手动序列化）
string json = JsonSerializer.Serialize(new { width = 1500, height = 2000 });
await WebView.CoreWebView2.ExecuteScriptAsync($"updateState({json})");
```

#### JavaScript 端：定义函数

```javascript
// 定义可被 C# 调用的函数
window.updateUI = function(status) {
    document.getElementById('status').textContent = status;
};

window.getUsername = function() {
    return document.getElementById('username').value;
};

window.updateState = function(state) {
    console.log('收到状态更新:', state);
    // 更新 Vue 状态
    app.state.width = state.width;
    app.state.height = state.height;
};
```

### 4.3 优点

- ✅ **C# 主动调用**：不需要等待 JavaScript 发起
- ✅ **获取返回值**：可以获取 JavaScript 函数的返回值
- ✅ **灵活**：可以执行任意 JavaScript 代码

### 4.4 缺点

- ❌ **字符串拼接**：容易出错，不安全
- ❌ **类型不安全**：返回值是字符串，需要手动解析
- ❌ **调试困难**：错误信息不清晰
- ❌ **性能开销**：每次调用都需要解析和执行

### 4.5 适用场景

- C# 主动通知 JavaScript（状态变化、进度更新）
- 调用 JavaScript 的工具函数
- 动态修改 DOM

### 4.6 完整示例

#### 示例 1：更新进度条

```csharp
// C# 端
public async Task ProcessDataAsync()
{
    for (int i = 0; i <= 100; i += 10)
    {
        // 更新 JavaScript 进度条
        await WebView.CoreWebView2.ExecuteScriptAsync($"updateProgress({i})");
        await Task.Delay(500);
    }
}
```

```javascript
// JavaScript 端
window.updateProgress = function(percent) {
    document.getElementById('progress').style.width = percent + '%';
    document.getElementById('progress-text').textContent = percent + '%';
};
```

#### 示例 2：获取表单数据

```csharp
// C# 端
public async Task<UserData> GetFormDataAsync()
{
    string json = await WebView.CoreWebView2.ExecuteScriptAsync("getFormData()");
    return JsonSerializer.Deserialize<UserData>(json);
}
```

```javascript
// JavaScript 端
window.getFormData = function() {
    return JSON.stringify({
        username: document.getElementById('username').value,
        email: document.getElementById('email').value
    });
};
```

---

## 5. 方式四：消息管道（CoreWebView2WebMessagePipe）

### 5.1 原理

建立 C# 与 JavaScript 之间的**双向流式通信管道**，支持高频率、低延迟的数据传输。

```
┌─────────────┐                    ┌─────────────┐
│  JavaScript │ <═══════════════> │     C#      │
│             │   消息管道          │             │
│             │   双向流式通信       │             │
└─────────────┘                    └─────────────┘
```

### 5.2 实现代码

#### C# 端：创建消息管道

```csharp
private CoreWebView2WebMessagePipe? _messagePipe;

private async Task InitializeWebViewAsync()
{
    await WebView.EnsureCoreWebView2Async();

    // 创建消息管道
    _messagePipe = await WebView.CoreWebView2.CreateWebMessagePipeAsync("myPipe");

    // 监听消息
    _messagePipe.MessageReceived += OnPipeMessageReceived;

    // 加载页面
    WebView.CoreWebView2.Navigate("https://revitflow.local/index.html");
}

private void OnPipeMessageReceived(object? sender, CoreWebView2WebMessageReceivedEventArgs e)
{
    var message = e.WebMessageAsJson;
    Console.WriteLine($"收到管道消息: {message}");

    // 回复消息
    _messagePipe?.PostMessage($"{{\"echo\": \"{message}\"}}");
}
```

#### JavaScript 端：使用消息管道

```javascript
// 获取消息管道
const pipe = window.chrome.webview.pipes.myPipe;

// 监听消息
pipe.addEventListener('message', (event) => {
    console.log('收到 C# 消息:', event.data);
});

// 发送消息
pipe.postMessage(JSON.stringify({
    type: 'data',
    value: 123
}));
```

### 5.3 优点

- ✅ **双向通信**：C# 和 JavaScript 都可以主动发送消息
- ✅ **高性能**：专为高频通信设计
- ✅ **低延迟**：比 postMessage 更快
- ✅ **流式传输**：适合实时数据流

### 5.4 缺点

- ❌ **API 复杂**：需要管理管道生命周期
- ❌ **兼容性**：需要较新版本的 WebView2 Runtime
- ❌ **调试困难**：消息流难以追踪

### 5.5 适用场景

- 实时数据流（传感器数据、日志流）
- 高频率通信（游戏、动画）
- 双向推送（聊天、协作）

### 5.6 完整示例：实时日志流

```csharp
// C# 端
private CoreWebView2WebMessagePipe? _logPipe;

private async Task InitializeLogPipeAsync()
{
    _logPipe = await WebView.CoreWebView2.CreateWebMessagePipeAsync("logPipe");

    // 模拟日志流
    _ = Task.Run(async () =>
    {
        while (true)
        {
            var log = new
            {
                timestamp = DateTime.Now.ToString("HH:mm:ss"),
                level = "INFO",
                message = "处理中..."
            };

            _logPipe?.PostMessage(JsonSerializer.Serialize(log));
            await Task.Delay(1000);
        }
    });
}
```

```javascript
// JavaScript 端
const logPipe = window.chrome.webview.pipes.logPipe;

logPipe.addEventListener('message', (event) => {
    const log = JSON.parse(event.data);
    console.log(`[${log.timestamp}] ${log.level}: ${log.message}`);

    // 添加到日志列表
    const logElement = document.createElement('div');
    logElement.textContent = `[${log.timestamp}] ${log.message}`;
    document.getElementById('logs').appendChild(logElement);
});
```

---

## 6. 方式对比与选择

### 6.1 功能对比

| 特性 | postMessage | HostObjects | ExecuteScript | 消息管道 |
|------|-------------|-------------|---------------|----------|
| **方向** | JS → C# | C# ↔ JS | C# → JS | C# ↔ JS |
| **返回值** | ❌ | ✅ | ✅ | ❌ |
| **异步支持** | ✅ | ✅ | ✅ | ✅ |
| **类型安全** | ⚠️ JSON | ✅ | ❌ 字符串 | ⚠️ JSON |
| **性能** | 中 | 低 | 低 | 高 |
| **复杂度** | 低 | 中 | 低 | 高 |
| **调试难度** | 低 | 中 | 高 | 高 |

### 6.2 选择建议

#### 使用 postMessage（推荐）

- ✅ 事件通知（按钮点击、表单提交）
- ✅ 命令调用（创建洞口、保存设置）
- ✅ 状态更新（修改 ViewModel 属性）
- ✅ 大部分常规场景

**理由**：简单、可靠、易于调试，适合 90% 的场景。

#### 使用 HostObjects

- ✅ 需要获取返回值
- ✅ 频繁调用 C# 方法
- ✅ 简单的数据查询

**注意**：需要 COM 可见，有性能开销。

#### 使用 ExecuteScriptAsync

- ✅ C# 主动通知 JavaScript
- ✅ 更新 UI 状态
- ✅ 调用 JavaScript 工具函数

**注意**：字符串拼接容易出错，谨慎使用。

#### 使用消息管道

- ✅ 实时数据流
- ✅ 高频率通信
- ✅ 双向推送

**注意**：API 复杂，仅在必要时使用。

---

## 7. 混合使用场景

在实际项目中，通常会**混合使用**多种通信方式。

### 7.1 场景 1：MVVM 架构（当前实现）

```
postMessage (JS → C#)
  ↓
  用于命令调用和状态更新

ExecuteScriptAsync (C# → JS)
  ↓
  用于主动通知 JavaScript（可选）
```

**示例**：

```csharp
// JavaScript 调用 C# 命令
window.RevitBridge.invoke('invokeCommand', { command: 'CreateOpening' });

// C# 完成后通知 JavaScript
await WebView.CoreWebView2.ExecuteScriptAsync("showSuccessMessage('洞口创建成功')");
```

### 7.2 场景 2：实时数据 + 命令调用

```
消息管道 (C# ↔ JS)
  ↓
  用于实时数据流（日志、进度）

postMessage (JS → C#)
  ↓
  用于命令调用
```

**示例**：

```csharp
// 消息管道：实时日志
_logPipe?.PostMessage(JsonSerializer.Serialize(new { message = "处理中..." }));

// postMessage：命令调用
WebView.CoreWebView2.WebMessageReceived += (s, e) => {
    // 处理命令
};
```

### 7.3 场景 3：查询 + 通知

```
HostObjects (JS → C#)
  ↓
  用于查询数据（获取配置、状态）

ExecuteScriptAsync (C# → JS)
  ↓
  用于主动通知（状态变化）
```

**示例**：

```javascript
// 查询配置
const config = window.chrome.webview.hostObjects.bridge.GetConfig();

// C# 主动通知配置变化
await WebView.CoreWebView2.ExecuteScriptAsync("onConfigChanged()");
```

---

## 8. 最佳实践

### 8.1 优先使用 postMessage

对于大部分场景，**postMessage 是最佳选择**：

```javascript
// ✅ 推荐：使用 postMessage
window.RevitBridge.invoke('setState', { width: 1500 });
```

```javascript
// ❌ 不推荐：使用 HostObjects（除非必要）
window.chrome.webview.hostObjects.bridge.SetWidth(1500);
```

### 8.2 封装通信层

创建统一的通信接口，隐藏底层实现：

```javascript
// useRevitBridge.js
export function useRevitBridge() {
    function setState(updates) {
        window.RevitBridge.invoke('setState', updates);
    }

    function invokeCommand(commandName, param) {
        window.RevitBridge.invoke('invokeCommand', {
            command: commandName,
            param: param
        });
    }

    return { setState, invokeCommand };
}
```

### 8.3 错误处理

所有通信都应该有错误处理：

```csharp
// C# 端
private void OnWebMessageReceived(object? sender, CoreWebView2WebMessageReceivedEventArgs e)
{
    try
    {
        var message = e.WebMessageAsJson;
        HandleMessage(message);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "处理消息失败");
        // 通知 JavaScript
        WebView.CoreWebView2.ExecuteScriptAsync($"showError('{ex.Message}')");
    }
}
```

```javascript
// JavaScript 端
try {
    window.RevitBridge.invoke('setState', { width: 1500 });
} catch (error) {
    console.error('通信失败:', error);
}
```

### 8.4 日志记录

记录所有通信消息，便于调试：

```csharp
private void OnWebMessageReceived(object? sender, CoreWebView2WebMessageReceivedEventArgs e)
{
    var message = e.WebMessageAsJson;
    _logger.LogDebug("收到消息: {Message}", message);
    // 处理消息...
}
```

```javascript
window.RevitBridge = {
    invoke: function(messageType, payload) {
        console.log('[RevitBridge] 发送消息:', messageType, payload);
        window.chrome.webview.postMessage({
            messageType: messageType,
            payload: payload
        });
    }
};
```

---

## 9. 总结

### 9.1 推荐方案

对于 RevitFlow 项目，推荐使用：

1. **主要通信**：postMessage（当前实现）
2. **辅助通信**：ExecuteScriptAsync（C# 主动通知）
3. **特殊场景**：HostObjects（需要返回值时）

### 9.2 核心原则

- ✅ **简单优先**：优先使用 postMessage
- ✅ **封装隔离**：通过桥接层隐藏细节
- ✅ **错误处理**：所有通信都要有错误处理
- ✅ **日志记录**：记录所有通信消息

---

## 10. 其他架构方案（了解）

除了当前使用的 WebView2 方案，还有其他两种常见的架构方案。

### 10.1 纯 Web 方案（HTTP 服务器）

#### 架构图

```
┌─────────────────┐         ┌─────────────────┐         ┌─────────────────┐
│  Revit 插件     │         │  HTTP 服务器    │         │  浏览器/WebView2 │
│                 │ 启动    │  (ASP.NET Core) │ HTTP    │                 │
│  C# 业务逻辑    │────────>│                 │<───────>│  Vue 应用       │
│                 │         │  RESTful API    │         │                 │
└─────────────────┘         └─────────────────┘         └─────────────────┘
```

#### 实现方式

```csharp
// Revit 插件启动 HTTP 服务器
public class Application : IExternalApplication
{
    private WebApplication? _webApp;

    public Result OnStartup(UIControlledApplication application)
    {
        // 启动 ASP.NET Core 服务器
        var builder = WebApplication.CreateBuilder();
        builder.Services.AddControllers();
        builder.Services.AddCors();

        _webApp = builder.Build();
        _webApp.UseCors(policy => policy.AllowAnyOrigin());
        _webApp.MapControllers();

        // 在后台线程启动服务器
        Task.Run(() => _webApp.RunAsync("http://localhost:5000"));

        return Result.Succeeded;
    }
}

// API 控制器
[ApiController]
[Route("api/[controller]")]
public class WallOpeningController : ControllerBase
{
    [HttpPost("create")]
    public IActionResult CreateOpening([FromBody] OpeningRequest request)
    {
        // 调用 Revit API
        return Ok(new { success = true });
    }
}
```

```javascript
// Vue 端通过 HTTP 调用
async function createOpening() {
    const response = await fetch('http://localhost:5000/api/wallopening/create', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ width: 1500, height: 2000 })
    });

    const result = await response.json();
    console.log(result);
}
```

#### 优点

- ✅ **前端完全独立**：可以用任何浏览器访问
- ✅ **支持热更新**：前端修改立即生效
- ✅ **标准 HTTP**：使用成熟的 RESTful API
- ✅ **易于测试**：可以用 Postman 等工具测试
- ✅ **跨平台**：前端可以在任何设备上运行

#### 缺点

- ❌ **跨域问题**：需要配置 CORS
- ❌ **安全问题**：本地端口暴露，需要认证
- ❌ **性能开销**：HTTP 请求比进程内通信慢
- ❌ **端口冲突**：可能与其他应用冲突
- ❌ **复杂度高**：需要管理服务器生命周期

#### 适用场景

- 需要远程访问（多设备协同）
- 前端团队独立开发
- 需要支持多种客户端（Web、移动端）

---

### 10.2 Electron-like 方案（Node.js 进程）

#### 架构图

```
┌─────────────────┐         ┌─────────────────┐         ┌─────────────────┐
│  Revit 插件     │  IPC    │  Node.js 进程   │  IPC    │  Vue 应用       │
│                 │<───────>│                 │<───────>│  (Electron)     │
│  C# 业务逻辑    │         │  中间层/桥接    │         │                 │
│                 │         │                 │         │  Chromium 渲染  │
└─────────────────┘         └─────────────────┘         └─────────────────┘
```

#### 实现方式

```csharp
// Revit 插件启动 Node.js 进程
public class Application : IExternalApplication
{
    private Process? _nodeProcess;

    public Result OnStartup(UIControlledApplication application)
    {
        // 启动 Node.js 进程
        _nodeProcess = new Process
        {
            StartInfo = new ProcessStartInfo
            {
                FileName = "node",
                Arguments = "server.js",
                WorkingDirectory = @"C:\RevitFlow\node",
                UseShellExecute = false,
                RedirectStandardInput = true,
                RedirectStandardOutput = true
            }
        };

        _nodeProcess.OutputDataReceived += OnNodeMessage;
        _nodeProcess.Start();
        _nodeProcess.BeginOutputReadLine();

        return Result.Succeeded;
    }

    private void OnNodeMessage(object sender, DataReceivedEventArgs e)
    {
        // 处理 Node.js 发来的消息
        var message = JsonSerializer.Deserialize<Message>(e.Data);
        HandleMessage(message);
    }

    public void SendToNode(object data)
    {
        var json = JsonSerializer.Serialize(data);
        _nodeProcess?.StandardInput.WriteLine(json);
    }
}
```

```javascript
// Node.js 中间层 (server.js)
const { app, BrowserWindow, ipcMain } = require('electron');

let mainWindow;

app.whenReady().then(() => {
    mainWindow = new BrowserWindow({
        width: 800,
        height: 600,
        webPreferences: {
            nodeIntegration: true,
            contextIsolation: false
        }
    });

    mainWindow.loadFile('index.html');

    // 监听来自 Vue 的消息
    ipcMain.on('create-opening', (event, data) => {
        // 转发给 C# 进程
        process.stdout.write(JSON.stringify({
            type: 'create-opening',
            data: data
        }) + '\n');
    });
});

// 监听来自 C# 的消息
process.stdin.on('data', (data) => {
    const message = JSON.parse(data.toString());
    // 转发给 Vue
    mainWindow.webContents.send('revit-message', message);
});
```

```javascript
// Vue 端
const { ipcRenderer } = require('electron');

// 发送消息到 Revit
function createOpening() {
    ipcRenderer.send('create-opening', {
        width: 1500,
        height: 2000
    });
}

// 接收 Revit 消息
ipcRenderer.on('revit-message', (event, message) => {
    console.log('收到 Revit 消息:', message);
});
```

#### 优点

- ✅ **完整的桌面应用体验**：类似原生应用
- ✅ **Node.js 生态**：可以使用 npm 包
- ✅ **双向通信**：C# ↔ Node.js ↔ Vue
- ✅ **隔离性好**：前端和后端完全分离
- ✅ **开发体验好**：支持热更新、DevTools

#### 缺点

- ❌ **架构复杂**：需要管理多个进程
- ❌ **资源占用大**：Node.js + Chromium 内存占用高
- ❌ **部署复杂**：需要打包 Node.js 和 Electron
- ❌ **进程通信开销**：三层通信性能较差
- ❌ **调试困难**：需要同时调试 C#、Node.js、Vue

#### 适用场景

- 需要 Node.js 生态（如使用特定 npm 包）
- 前端需要完全独立开发和测试
- 需要复杂的前端功能（如文件系统访问）

---

### 10.3 三种方案对比

| 特性 | WebView2（当前） | HTTP 服务器 | Electron-like |
|------|------------------|-------------|---------------|
| **架构复杂度** | 低 | 中 | 高 |
| **性能** | 高 | 中 | 低 |
| **内存占用** | 低 | 中 | 高 |
| **前端独立性** | 低 | 高 | 高 |
| **热更新** | 需要构建 | 支持 | 支持 |
| **跨域问题** | 无 | 有 | 无 |
| **部署复杂度** | 低 | 中 | 高 |
| **调试难度** | 低 | 中 | 高 |
| **适合场景** | 单机插件 | 远程访问 | 复杂前端 |

### 10.4 为什么选择 WebView2？

对于 Revit 插件开发，**WebView2 是最佳选择**：

1. **简单可靠**：架构简单，易于维护
2. **性能优秀**：进程内通信，延迟低
3. **资源占用小**：共享系统 Edge 浏览器
4. **部署简单**：只需要一个 DLL
5. **调试方便**：F12 开发者工具

HTTP 服务器和 Electron-like 方案适合：
- 需要远程访问的场景
- 前端团队完全独立开发
- 需要 Node.js 生态的复杂应用

但对于 Revit 插件这种**单机桌面应用**，WebView2 是最合适的。

---

### 9.3 扩展阅读

- [WebView2 官方文档](https://learn.microsoft.com/en-us/microsoft-edge/webview2/)
- [postMessage API](https://learn.microsoft.com/en-us/microsoft-edge/webview2/how-to/communicate-btwn-web-native)
- [HostObjects 文档](https://learn.microsoft.com/en-us/microsoft-edge/webview2/how-to/hostobject)
- [ExecuteScriptAsync 文档](https://learn.microsoft.com/en-us/dotnet/api/microsoft.web.webview2.core.corewebview2.executescriptasync)
- [ASP.NET Core 文档](https://learn.microsoft.com/en-us/aspnet/core/)
- [Electron 文档](https://www.electronjs.org/docs/latest/)
