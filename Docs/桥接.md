 # JavaScript 与 C# 桥接机制详解

本文档用通俗易懂的方式解释 RevitFlow 中 JavaScript 与 C# 的桥接机制。

---

## 目录

1. [什么是桥接机制](#1-什么是桥接机制)
2. [为什么需要桥接](#2-为什么需要桥接)
3. [桥接的工作原理](#3-桥接的工作原理)
4. [完整执行流程](#4-完整执行流程)
5. [用快递类比理解](#5-用快递类比理解)
6. [实际代码示例](#6-实际代码示例)
7. [常见问题](#7-常见问题)

---

## 1. 什么是桥接机制

### 1.1 问题背景

**JavaScript 和 C# 是两个不同的世界**，它们无法直接对话：

```
┌─────────────┐                    ┌─────────────┐
│  JavaScript │                    │     C#      │
│   (Vue)     │   ❌ 无法直接通信   │  (ViewModel)│
└─────────────┘                    └─────────────┘
```

- JavaScript 运行在 WebView2 的浏览器进程中
- C# 运行在 WPF 应用程序进程中
- 两者在不同的内存空间，不能直接访问对方的变量和函数

### 1.2 WebView2 提供的"邮局"

WebView2 提供了一个**消息传递机制**（类似邮局）：

```javascript
// JavaScript 端：发送消息
window.chrome.webview.postMessage({ ... });
```

```csharp
// C# 端：接收消息
WebView.CoreWebView2.WebMessageReceived += (sender, e) => {
    var message = e.WebMessageAsJson;
};
```

**问题**：这个 API 太原始，使用起来很麻烦。

### 1.3 我们的解决方案：RevitBridge

我们创建了一个**桥接对象** `RevitBridge`，封装了 WebView2 的原始 API：

```javascript
// 使用桥接（简单）
window.RevitBridge.invoke('setState', { width: 1500 });

// 原始方式（麻烦）
window.chrome.webview.postMessage({
    messageType: 'setState',
    payload: { width: 1500 }
});
```

---

## 2. 为什么需要桥接

### 2.1 简化调用

**没有桥接**：每次都要写完整的消息格式

```javascript
// ❌ 繁琐：每次都要写这么多
window.chrome.webview.postMessage({
    messageType: 'setState',
    payload: { width: 1500, height: 2000 }
});

window.chrome.webview.postMessage({
    messageType: 'invokeCommand',
    payload: { command: 'CreateOpening' }
});
```

**有桥接**：调用简洁明了

```javascript
// ✅ 简洁：统一的调用方式
window.RevitBridge.invoke('setState', { width: 1500, height: 2000 });
window.RevitBridge.invoke('invokeCommand', { command: 'CreateOpening' });
```

### 2.2 避免错误

**没有桥接**：容易拼错字段名

```javascript
// ❌ 容易出错
window.chrome.webview.postMessage({
    msgType: 'setState',      // ← 错了！应该是 messageType
    data: { width: 1500 }     // ← 错了！应该是 payload
});
```

**有桥接**：格式由桥接保证

```javascript
// ✅ 不会出错：桥接内部自动生成正确格式
window.RevitBridge.invoke('setState', { width: 1500 });
```

### 2.3 方便扩展

**没有桥接**：每个调用都要修改

```javascript
// ❌ 如果要添加日志，每个地方都要改
window.chrome.webview.postMessage({ ... });
console.log('发送消息');  // 每次都要加

window.chrome.webview.postMessage({ ... });
console.log('发送消息');  // 每次都要加
```

**有桥接**：只改一个地方

```javascript
// ✅ 在桥接中统一添加功能
window.RevitBridge = {
    invoke: function(messageType, payload) {
        // 统一添加日志
        console.log('发送消息:', messageType, payload);

        // 统一错误处理
        try {
            window.chrome.webview.postMessage({
                messageType: messageType,
                payload: payload || {}
            });
        } catch (error) {
            console.error('发送失败:', error);
        }
    }
};
```

---

## 3. 桥接的工作原理

### 3.1 桥接脚本注入

在页面加载**之前**，C# 会注入一段 JavaScript 代码：

```csharp
// C# 端：注入桥接脚本
private async Task InjectBridgeScriptAsync()
{
    const string bridgeScript = """
        window.RevitBridge = {
            invoke: function(messageType, payload) {
                window.chrome.webview.postMessage({
                    messageType: messageType,
                    payload: payload || {}
                });
            }
        };
        console.log('RevitBridge 已注入');
        """;

    await WebView.CoreWebView2.AddScriptToExecuteOnDocumentCreatedAsync(bridgeScript);
}
```

**关键点**：
- `AddScriptToExecuteOnDocumentCreatedAsync`：在**每个页面加载前**自动执行
- 即使页面刷新，脚本也会重新注入
- 确保 `window.RevitBridge` 始终可用

### 3.2 桥接对象结构

注入后，JavaScript 环境中会有这个对象：

```javascript
window.RevitBridge = {
    invoke: function(messageType, payload) {
        // 1. 封装消息格式
        var message = {
            messageType: messageType,
            payload: payload || {}
        };

        // 2. 调用 WebView2 原生 API
        window.chrome.webview.postMessage(message);
    }
};
```

**作用**：
- 封装 WebView2 的原生 API
- 统一消息格式
- 提供简洁的调用接口

### 3.3 消息传递流程

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Vue 调用                                                  │
│    window.RevitBridge.invoke('setState', { width: 1500 })   │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. RevitBridge 封装                                          │
│    window.chrome.webview.postMessage({                       │
│        messageType: 'setState',                              │
│        payload: { width: 1500 }                              │
│    })                                                        │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. WebView2 处理（黑盒）                                      │
│    - 序列化 JSON                                             │
│    - 进程间通信（IPC）                                        │
│    - 发送到 C# 进程                                           │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. C# 接收                                                   │
│    WebMessageReceived 事件触发                                │
│    var message = e.WebMessageAsJson;                         │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. 完整执行流程

### 场景：用户点击"创建洞口"按钮

#### 步骤 1：Vue 组件（用户界面）

```vue
<template>
  <button @click="createOpening">创建洞口</button>
</template>

<script setup>
import { useRevitBridge } from './composables/useRevitBridge'

const { invokeCommand } = useRevitBridge()

function createOpening() {
  console.log('1. Vue: 用户点击按钮');
  invokeCommand('CreateOpening');
}
</script>
```

#### 步骤 2：useRevitBridge.js（封装层）

```javascript
export function useRevitBridge() {
  function invokeCommand(commandName, param) {
    console.log('2. Composable: 调用 RevitBridge');

    window.RevitBridge.invoke('invokeCommand', {
      command: commandName,
      param: param
    });
  }

  return { invokeCommand };
}
```

#### 步骤 3：RevitBridge（注入的桥接脚本）

```javascript
window.RevitBridge = {
  invoke: function(messageType, payload) {
    console.log('3. Bridge: 转发到 WebView2');
    console.log('   messageType:', messageType);
    console.log('   payload:', payload);

    // 调用 WebView2 的原生 API
    window.chrome.webview.postMessage({
      messageType: messageType,
      payload: payload || {}
    });
  }
};
```

#### 步骤 4：WebView2（黑盒，自动处理）

```
4. WebView2: 序列化 JSON
   {
     "messageType": "invokeCommand",
     "payload": {
       "command": "CreateOpening",
       "param": null
     }
   }

5. WebView2: 通过 IPC 发送到 C# 进程
```

#### 步骤 5：C# 接收（WebViewBase.cs）

```csharp
private void OnWebMessageReceived(object? sender, CoreWebView2WebMessageReceivedEventArgs e)
{
    Console.WriteLine("6. C#: 收到消息");

    var message = e.WebMessageAsJson;
    Console.WriteLine($"   JSON: {message}");

    var json = JsonDocument.Parse(message);
    var messageType = json.GetProperty("messageType").GetString();
    var payload = json.GetProperty("payload");

    Console.WriteLine($"   messageType: {messageType}");

    HandleMessage(messageType!, payload);
}
```

#### 步骤 6：消息分发

```csharp
private void HandleMessage(string messageType, JsonElement payload)
{
    Console.WriteLine("7. C#: 分发消息");

    switch (messageType)
    {
        case "setState":
            SetViewModelState(payload);
            break;
        case "invokeCommand":
            var commandName = payload.GetProperty("command").GetString();
            InvokeCommand(commandName!, null);
            break;
    }
}
```

#### 步骤 7：反射调用命令

```csharp
private void InvokeCommand(string commandName, string? param)
{
    Console.WriteLine("8. C#: 通过反射调用命令");

    var commandProp = _viewModel.GetType().GetProperty(commandName + "Command");
    var command = commandProp?.GetValue(_viewModel) as ICommand;

    if (command != null && command.CanExecute(param))
    {
        Console.WriteLine($"   执行: {commandName}Command");
        command.Execute(param);
    }
}
```

#### 步骤 8：ViewModel 执行

```csharp
[RelayCommand]
private void CreateOpening()
{
    Console.WriteLine("9. ViewModel: 执行业务逻辑");

    _handler.Width = Width;
    _handler.Height = Height;

    Console.WriteLine("10. ViewModel: 触发 ExternalEvent");
    _externalEvent.Raise();
}
```

---

## 5. 用快递类比理解

### 5.1 角色对应

| 角色             | 对应                    | 职责           |
| ---------------- | ----------------------- | -------------- |
| **你（寄件人）** | Vue 组件                | 发起请求       |
| **快递公司**     | RevitBridge             | 封装、转发消息 |
| **邮局**         | WebView2 的 postMessage | 底层传输       |
| **收件人**       | C# ViewModel            | 处理请求       |

### 5.2 寄快递的过程

#### 没有快递公司（没有桥接）

```
你 → 自己去邮局 → 填复杂的表格 → 寄出
```

**问题**：
- 每次都要去邮局
- 每次都要填表格
- 容易填错
- 很麻烦

#### 有快递公司（有桥接）

```
你 → 打电话给快递公司 → 快递公司帮你处理 → 寄出
```

**优势**：
- 只需要一个电话
- 快递公司帮你打包、填单
- 不会出错
- 很方便

### 5.3 代码对应

#### 你打电话（Vue 调用）

```javascript
// 你：我要寄快递
window.RevitBridge.invoke('invokeCommand', {
    command: 'CreateOpening'
});
```

#### 快递公司处理（RevitBridge）

```javascript
invoke: function(messageType, payload) {
    // 快递公司：好的，我帮你打包、填单、寄出
    window.chrome.webview.postMessage({
        messageType: messageType,
        payload: payload || {}
    });
}
```

#### 邮局运输（WebView2）

```
JavaScript 进程 → [序列化] → [IPC] → C# 进程
```

#### 收件人收货（C# 接收）

```csharp
WebMessageReceived += (sender, e) => {
    // 收件人：收到快递，拆包
    var message = e.WebMessageAsJson;

    // 看看是什么
    var json = JsonDocument.Parse(message);
    var messageType = json.GetProperty("messageType").GetString();

    // 处理
    HandleMessage(messageType, payload);
};
```

---

## 6. 实际代码示例

### 6.1 示例 1：更新 ViewModel 属性

#### JavaScript 端

```javascript
// Vue 组件中
<input
  v-model="state.width"
  @change="setState({ width: state.width })"
/>

// useRevitBridge.js
function setState(updates) {
  window.RevitBridge.invoke('setState', updates);
}
```

#### 桥接处理

```javascript
window.RevitBridge = {
  invoke: function(messageType, payload) {
    // messageType = 'setState'
    // payload = { width: 1500 }

    window.chrome.webview.postMessage({
      messageType: 'setState',
      payload: { width: 1500 }
    });
  }
};
```

#### C# 端

```csharp
private void HandleMessage(string messageType, JsonElement payload)
{
    if (messageType == "setState")
    {
        SetViewModelState(payload);
    }
}

private void SetViewModelState(JsonElement payload)
{
    // payload = { "width": 1500 }

    foreach (var prop in payload.EnumerateObject())
    {
        // prop.Name = "width"
        // prop.Value = 1500

        var propName = "Width";  // 转换为 PascalCase
        var vmProp = _viewModel.GetType().GetProperty(propName);

        var value = JsonSerializer.Deserialize(prop.Value.GetRawText(), vmProp.PropertyType);
        // value = 1500 (double)

        vmProp.SetValue(_viewModel, value);
        // _viewModel.Width = 1500
    }
}
```

### 6.2 示例 2：调用 ViewModel 命令

#### JavaScript 端

```javascript
// Vue 组件中
<button @click="createOpening">创建洞口</button>

function createOpening() {
  invokeCommand('CreateOpening');
}

// useRevitBridge.js
function invokeCommand(commandName, param) {
  window.RevitBridge.invoke('invokeCommand', {
    command: commandName,
    param: param
  });
}
```

#### 桥接处理

```javascript
window.RevitBridge = {
  invoke: function(messageType, payload) {
    // messageType = 'invokeCommand'
    // payload = { command: 'CreateOpening', param: undefined }

    window.chrome.webview.postMessage({
      messageType: 'invokeCommand',
      payload: { command: 'CreateOpening', param: undefined }
    });
  }
};
```

#### C# 端

```csharp
private void HandleMessage(string messageType, JsonElement payload)
{
    if (messageType == "invokeCommand")
    {
        var commandName = payload.GetProperty("command").GetString();
        // commandName = "CreateOpening"

        var commandParam = payload.TryGetProperty("param", out var p) ? p.GetString() : null;
        // commandParam = null

        InvokeCommand(commandName!, commandParam);
    }
}

private void InvokeCommand(string commandName, string? param)
{
    // commandName = "CreateOpening"

    var commandProp = _viewModel.GetType().GetProperty("CreateOpeningCommand");
    var command = commandProp?.GetValue(_viewModel) as ICommand;

    if (command != null && command.CanExecute(param))
    {
        command.Execute(param);
        // 执行 _viewModel.CreateOpeningCommand.Execute(null)
    }
}
```

---

## 7. 常见问题

### Q1: 为什么不直接使用 `window.chrome.webview.postMessage`？

**答**：可以，但是：

1. **代码重复**：每次都要写完整的消息格式
2. **容易出错**：字段名可能拼错
3. **难以维护**：如果要修改消息格式，需要改很多地方
4. **不方便扩展**：添加日志、错误处理等功能很麻烦

桥接封装了这些细节，让代码更简洁、更可靠。

### Q2: 桥接脚本什么时候注入？

**答**：在**每个页面加载前**自动注入。

```csharp
await WebView.CoreWebView2.AddScriptToExecuteOnDocumentCreatedAsync(bridgeScript);
```

- 使用 `AddScriptToExecuteOnDocumentCreatedAsync` 方法
- 在 DOM 创建之前执行
- 即使页面刷新，也会重新注入
- 确保 `window.RevitBridge` 始终可用

### Q3: 如果页面刷新，桥接会失效吗？

**答**：不会。

因为使用了 `AddScriptToExecuteOnDocumentCreatedAsync`，每次页面加载都会重新注入脚本。

### Q4: 桥接有性能损耗吗？

**答**：几乎没有。

桥接只是一个简单的函数调用，性能损耗可以忽略不计（纳秒级）。真正的性能瓶颈在于：
- JSON 序列化/反序列化（微秒级）
- 进程间通信（毫秒级）
- 反射调用（微秒级）

但在 UI 交互场景下，这些都是可以接受的。

### Q5: 可以扩展桥接功能吗？

**答**：可以。

例如，添加日志、错误处理、重试机制：

```javascript
window.RevitBridge = {
    invoke: function(messageType, payload) {
        // 添加日志
        console.log('[RevitBridge] 发送消息:', messageType, payload);

        // 添加错误处理
        try {
            window.chrome.webview.postMessage({
                messageType: messageType,
                payload: payload || {}
            });
        } catch (error) {
            console.error('[RevitBridge] 发送失败:', error);

            // 可以添加重试逻辑
            setTimeout(() => {
                this.invoke(messageType, payload);
            }, 1000);
        }
    }
};
```

### Q6: 桥接支持双向通信吗？

**答**：当前实现是**单向的**（JavaScript → C#）。

如果需要 C# → JavaScript 的通信，可以使用：

```csharp
// C# 调用 JavaScript
await WebView.CoreWebView2.ExecuteScriptAsync("alert('Hello from C#')");
```

但在 MVVM 架构中，通常不需要 C# 主动调用 JavaScript，因为：
- ViewModel 的状态变化会自动反映到 Vue（通过 `setState`）
- Vue 通过数据绑定自动更新 UI

---

## 8. 总结

### 桥接机制的本质

**桥接就是一个"快递服务"**，它：

1. **简化调用**：封装复杂的 API
2. **统一格式**：确保消息格式正确
3. **方便扩展**：可以添加日志、错误处理等
4. **解耦**：Vue 不需要知道 WebView2 的细节

### 核心代码

桥接的核心代码只有几行：

```javascript
window.RevitBridge = {
    invoke: function(messageType, payload) {
        window.chrome.webview.postMessage({
            messageType: messageType,
            payload: payload || {}
        });
    }
};
```

但它让整个通信变得：
- ✅ 简单
- ✅ 可靠
- ✅ 易维护
- ✅ 易扩展

### 完整流程

```
Vue 组件
  ↓ 调用
useRevitBridge
  ↓ 调用
RevitBridge (桥接)
  ↓ 调用
window.chrome.webview.postMessage (WebView2 API)
  ↓ 序列化 + IPC
C# WebMessageReceived 事件
  ↓ 解析 JSON
HandleMessage
  ↓ 分发
SetViewModelState / InvokeCommand
  ↓ 反射
ViewModel 属性/命令
```

---

## 9. 扩展阅读

- [WebView2 官方文档](https://learn.microsoft.com/en-us/microsoft-edge/webview2/)
- [postMessage API](https://learn.microsoft.com/en-us/microsoft-edge/webview2/how-to/communicate-btwn-web-native)
- [进程间通信（IPC）](https://en.wikipedia.org/wiki/Inter-process_communication)
